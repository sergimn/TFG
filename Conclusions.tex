% Plataformes embedded son inestables en natura, s'ha de posar molta cura en el desenvolupament i en l'arquitectura del hardware
% Debuggar un sistema que té tasques és més difícil del que sembla ja que la interacció de diferents components que s'executen de manera asíncrona pot dificultar que es pugui trobar l'arrel de un problema
% El protocol de telemetria s'ha de pensar cuidadosament, ja que és facil que ocupi tot el duty cicle disponible
This project has had many turn of events that we didn't predict at the beginning, be it for lack of research or bad luck or a mix of both. However, as the old say goes \textit{it's about the journey, not the destination} and many things were learned through the process of the research.
The most obvious one is that there is never \textit{enough} research done on the topic you will be working on, specially if this topic is microcontrollers manufactured in China with not an optimal amount of trustful documentation. Many of the problems and time wasted could have been avoided if more research would have been done on the hardware used, unfortunately, this would have required additional time and resources that we and the department didn't have and it has also lead to a situation where we have done other stuff that in turn has taught something else.

One of the topics that has continuously come up during the research is the instability of the embedded device used. One of the devices failed early on --even though it wasn't a show stopper but there was some time involved trying to figure out if was a software issue--, something that rarely happens when programming for devices of conventional purpose as the hardware is inherently trusted and completely transparent. However, here we needed to constantly take the hardware capabilities into account and look for workarounds when something didn't work as expected, such as the Watchdog Timer crashes, or specific constraints due to the low amount of resources, such as the requirements with the ISR. And because those constraints are not explicitly advertised, the issues we faced were mostly unexpected.

Moreover, programming a system that has many asynchronous tasks that interact with each other can lead to bugs where it is troublesome to find the root cause of. Because different flows of execution can modify the same variable and interact with the same data or leave the system in an unstable but symptomless state, that will later cause problems in another unrelated task, is has been important to pay close attention to how each task modifies the variables and memory and use the hardware debugger properly. There are other corner cases that are difficult to observe and replicate that also need special attention such as wanting to transmit data while the device is transmitting one of the periodic packets of telemetry that make the system unstable and not transmit any of the packets properly.

In addition, special thought needs to be put on the telemetry relaying mechanism that allows the nodes to build a routing table to reach other nodes. The current implementation sends data every 30 seconds and, at the current bitrate, takes about 1s to transmit, which is an effective duty cycle of $ 1/30 = 3.3\% $, 3 times more than the allowed by the current EU regulations, which makes this periodicity unfeasible and it would need to be dropped to at least every 100s or 1 minute 40s, and this case wouldn't consider the transmission of data. In order to solve this matter we could optimize the transmission of telemetry, which is currently highly inefficient and considerably increase the periodicity of telemetry transmission as, once the nodes have stable software, they should rarely stop working, as long as they have power, of course.
