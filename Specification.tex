% Parlar sobre què fa la llibreria i com ho fa
		% - Retransmetre paquets de control de forma periòdica que construeixen un mapa de la xarxa
		% - Enviar paquets a nodes adjaçents
		% - Escoltar per paquets que arriben per posar-los a la taula de enrutament
% Parlar sobre FreeRTOS
    	% - Integrat en el sistema de ESP32, pelque no afegeix espai en el binari
    	% - Permet executar tasques recorrents sense la necessitat que l'usuari hi participi ja que es fa el setup quan s'inicialitza la classe
% Parlar sobre RadioLib
		% - Permet simplicitat de cara a l'usuari utilitzant la ISR (aprofitar per explicar què és una ISR)
		% - Suporta hardware molt diferent 
In its current state, the project is able communicate with close nodes that are in the range of the radio device. It relays the current nodes that each node has in reach and adds them to a topology map when it receives the appropriate message, building a routing table that tells what node is the best way to achieve every node on the network. Currently, the metric used is that every hop has a cost of 1 and the routing table stores the most efficient path, the one that has less cost. This topology building mechanism is somewhat similar to how RIP works. It can also send and receive preset messages but currently the library is not able to relay such messages for technical reasons that will be explained in the coming sections. %TODO Posar un link a la secció on s'explica la necessitat d'implementar una cua i perquè no és trivial de fer
In addition, it does all this things completely transparently to the user (or developer, in this case) as the control and telemetry communications are completely hidden and automated.

As mentioned in previous sections, we are developing this library for microcontrollers and thus, we need to adhere to their requirements and capabilities. It would be pointless to design a library that would work well on full desktop computers, that usually have a great amount of resources when this is the last place this code is going to run on. Systems like microcontrollers rarely have more than a few MB of memory available and they rarely have powerful processors, seldom having more than a few hundreds MHz CPU clocks. %TODO Posar una comparació entre els recursos de la TTGO i un PC normal per posar en evidència la limitació de recursos
This constraints force us to take certain considerations and careful thought when picking which underlying libraries we will use to accomplish our goals. Fortunately the right combination was found:
\subsection{RadioLib}
RadioLib\footnote{\url{https://github.com/jgromes/RadioLib}} is a \textit{Universal wireless communication library for Arduino}. It supports multiple board architectures such as AVR\footnote{\url{https://www.arduino.cc}}, Curie\footnote{\url{https://en.wikipedia.org/wiki/Intel_Quark}} or in the case that matters to us, ESP32\footnote{\url{https://en.wikipedia.org/wiki/ESP32}}. It also supports different modules for the comunication and different protocols ranging from MQTT to the one that is interesting to us, LoRa.

RadioLib was the library chosen among other available options not only for its ability to support different board configurations but also because of a specific feature it supports; being able to use the ISR as a callback mechanism when packets are received.
\subsubsection{The ISR}
The ISR or \textit{Interrupt Service Routine}
\subsubsection{How we use the ISR}
\subsection{FreeRTOS}
%TODO Afegir un diagrama (o dos) de com les tasques interactuen. Un diagrama de decisions hauria de ser suficient per representar l'esperit davant d'aquestes dues tasques
FreeRTOS\footnote{\url{https://www.freertos.org/RTOS.html}} is a Real Time Operating System kernel for microcontrollers that is used in the toolchain we use to build the binaries and upload them to the TTGO board. By default is is used to manage WiFi, BT and the \texttt{setup()} and \texttt{loop()} functions present in all Arduino ESP32\footnote{\url{https://docs.espressif.com/projects/arduino-esp32/en/latest/getting_started.html}} code. FreeRTOS is widely chosen in the industry for being tested, flexible, reliable, scalable and also very low profile, as the binary image rarely takes more than a few KB and it has a very low memory and CPU footprint\cite{FreeRTOSCharacteristics}. In addition, FreeRTOS also provides an easy way to program and schedule tasks that will allow us to exchange telemetry about the nodes periodically as well as delay message transmission for legal compliance issues. Moreover, it also has support for preemptive tasks through programmable interrupts and the ISR.
Because all of this features and because FreeRTOS was already baked into every binary we would generate.
\subsubsection{The tasks}
Currently, two FreeRTOS tasks are used in the library, there's a plan for a third one (and a possible fourth) that will be in charge of sending the messages when the device is allowed to use the radioelectric spectrum according to current regulations and will delay the transmission otherwise. The currently existing tasks, however, are responsible of the following:
\subsubsection*{Telemetry}
This task is in charge of relaying telemetry and routing information to other nodes in reach. This information is paramount in order to relay the information that will later allow the other nodes to make decisions to whether send a message and under which parameters to do so.

Because it is important that the user doesn't interact with this part (or at least, that they are not able to easily mess with the functionality) as it is what allows the main selling point of this library, we needed to think on a solution that works in a completely autonomous manner. For this reason, the task is initialized in the constructor of the class after setting up all and it has predefined parameters and it is also destroyed in the destructor of the class. Currently it transmits the device's routing table every 30 seconds, but this number is subject to change, probably to a higher period to comply with regulatory standards and also some sort of variance to the period will be introduced as that can reduce collisions\cite{Floyd1994} in broadcast environments, such as ours.

For this feature, other libraries were considered such as \textit{TaskScheduler}\footnote{\url{https://github.com/arkhipenko/TaskScheduler}} but FreeRTOS was the one that guaranteed a low performance impact, was well documented, and didn't have any issues with OOP.

\subsubsection*{Receiving messages}
Even though RadioLib is responsible of running an arbitrary code after a packet is received, as stated in %TODO Posar la secció on es parla de la ISR
, spendig a lot of time in the ISR must be prevented. For this reason, the only job the ISR has, is to signal this task that a new message is ready to be processed, thus freeing the ISR from high CPU utilization or blocking tasks. This task will then be responsible of treating the packet depending on its header. In normal data packets, the payload will be copied to a buffer that is accessible for the user and then a user provided function will be executed, probably under a different task context, so the user can treat the received data for their intended purpose. However, in case we receive a telemetry packet we expect to need a bit more of computing power --thus the need for this task-- as we will need to update the routing table with the potential new information and do some extra calculations if we want to optimize the routing table with some non trivial techniques that take into account things such as battery levels of nearby devices, Spread Factor or frequency used.

\subsubsection*{Sending Messages}
This task, not yet implemented, should be responsible of ensuring the legal compliance of the devices that use the library and only allow transmission of packets when they are not over the allowed transmission duty cycle
% Es fan servir 2 tasques
	% La periòdica de enviar telemetria. Explicar que perque aquesta funció fos transparent per l'usuari es necessitava fer servir freertos
	% La de rebre els paquets i processar la telemetria
	% En un futur, la d'enviar els paquets normals